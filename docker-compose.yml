services:
  postgres:
    image: postgres:16-alpine
    container_name: neutralpress-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: neutralpress
      POSTGRES_USER: neutralpress
      POSTGRES_PASSWORD: neutralpress
    volumes:
      - neutralpress-postgres-data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U neutralpress -d neutralpress"]
      interval: 5s
      timeout: 5s
      retries: 20

  redis:
    image: redis:7-alpine
    container_name: neutralpress-redis
    restart: unless-stopped
    command: ["redis-server", "--appendonly", "yes"]
    volumes:
      - neutralpress-redis-data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 20

  web:
    image: $${NEUTRALPRESS_IMAGE:-ghcr.io/ravelloh/neutralpress:latest}
    container_name: neutralpress-web
    restart: unless-stopped
    env_file:
      - .env
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    ports:
      - "3000:3000"

  watchtower:
    build:
      context: .
      dockerfile: docker/watchtower.Dockerfile
    image: neutralpress-watchtower:local
    container_name: neutralpress-watchtower
    restart: unless-stopped
    env_file:
      - .env
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      WATCHTOWER_HTTP_API_UPDATE: "true"
      WATCHTOWER_CLEANUP: "true"
    command: --http-api-update neutralpress-web

  init:
    image: node:22-alpine
    container_name: neutralpress-init
    restart: "no"
    env_file:
      - .env
    environment:
      BOOTSTRAP_URL: http://web:3000/internal/runtime/init
      BOOTSTRAP_RETRIES: 120
      BOOTSTRAP_INTERVAL_MS: 2000
      BOOTSTRAP_LABEL: runtime init
    depends_on:
      web:
        condition: service_started
    command:
      - /bin/sh
      - -c
      - |
        set -eu
        node <<'NODE'
        const { hkdfSync } = require("node:crypto");

        const endpoint = process.env.BOOTSTRAP_URL || "";
        const retries = Number.parseInt(process.env.BOOTSTRAP_RETRIES || "120", 10);
        const intervalMs = Number.parseInt(process.env.BOOTSTRAP_INTERVAL_MS || "2000", 10);
        const label = process.env.BOOTSTRAP_LABEL || "bootstrap";
        const masterSecret = (process.env.MASTER_SECRET || "").trim();

        if (!endpoint) {
          console.error(`$${label}: missing BOOTSTRAP_URL`);
          process.exit(1);
        }
        if (!masterSecret || masterSecret.length < 32) {
          console.error(`$${label}: MASTER_SECRET is missing or too short`);
          process.exit(1);
        }

        const token = Buffer.from(
          hkdfSync(
            "sha256",
            Buffer.from(masterSecret, "utf8"),
            Buffer.from("neutralpress", "utf8"),
            Buffer.from("cache-bootstrap-v1", "utf8"),
            32,
          ),
        ).toString("base64url");

        const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

        (async () => {
          for (let attempt = 1; attempt <= retries; attempt += 1) {
            try {
              const response = await fetch(endpoint, {
                method: "POST",
                headers: {
                  authorization: `Bearer $${token}`,
                  "content-type": "application/json",
                },
                body: JSON.stringify({
                  trigger: "docker-compose",
                }),
              });

              const body = await response.text();
              if (response.ok) {
                process.stdout.write(`$${body}\n`);
                process.exit(0);
              }

              console.error(
                `$${label} attempt $${attempt}/$${retries} failed: HTTP $${response.status}`,
              );
              if (body) {
                console.error(body);
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              console.error(`$${label} attempt $${attempt}/$${retries} failed: $${message}`);
            }

            if (attempt < retries) {
              await sleep(intervalMs);
            }
          }

          console.error(`$${label} failed after $${retries} attempts`);
          process.exit(1);
        })();
        NODE

  bootstrap-cache:
    image: node:22-alpine
    container_name: neutralpress-bootstrap-cache
    restart: "no"
    env_file:
      - .env
    environment:
      BOOTSTRAP_URL: http://web:3000/internal/cache/bootstrap
      BOOTSTRAP_RETRIES: 90
      BOOTSTRAP_INTERVAL_MS: 2000
      BOOTSTRAP_LABEL: cache bootstrap
    depends_on:
      init:
        condition: service_completed_successfully
    command:
      - /bin/sh
      - -c
      - |
        set -eu
        node <<'NODE'
        const { hkdfSync } = require("node:crypto");

        const endpoint = process.env.BOOTSTRAP_URL || "";
        const retries = Number.parseInt(process.env.BOOTSTRAP_RETRIES || "120", 10);
        const intervalMs = Number.parseInt(process.env.BOOTSTRAP_INTERVAL_MS || "2000", 10);
        const label = process.env.BOOTSTRAP_LABEL || "bootstrap";
        const masterSecret = (process.env.MASTER_SECRET || "").trim();

        if (!endpoint) {
          console.error(`$${label}: missing BOOTSTRAP_URL`);
          process.exit(1);
        }
        if (!masterSecret || masterSecret.length < 32) {
          console.error(`$${label}: MASTER_SECRET is missing or too short`);
          process.exit(1);
        }

        const token = Buffer.from(
          hkdfSync(
            "sha256",
            Buffer.from(masterSecret, "utf8"),
            Buffer.from("neutralpress", "utf8"),
            Buffer.from("cache-bootstrap-v1", "utf8"),
            32,
          ),
        ).toString("base64url");

        const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

        (async () => {
          for (let attempt = 1; attempt <= retries; attempt += 1) {
            try {
              const response = await fetch(endpoint, {
                method: "POST",
                headers: {
                  authorization: `Bearer $${token}`,
                  "content-type": "application/json",
                },
                body: JSON.stringify({
                  trigger: "docker-compose",
                }),
              });

              const body = await response.text();
              if (response.ok) {
                process.stdout.write(`$${body}\n`);
                process.exit(0);
              }

              console.error(
                `$${label} attempt $${attempt}/$${retries} failed: HTTP $${response.status}`,
              );
              if (body) {
                console.error(body);
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              console.error(`$${label} attempt $${attempt}/$${retries} failed: $${message}`);
            }

            if (attempt < retries) {
              await sleep(intervalMs);
            }
          }

          console.error(`$${label} failed after $${retries} attempts`);
          process.exit(1);
        })();
        NODE

volumes:
  neutralpress-postgres-data:
  neutralpress-redis-data:
