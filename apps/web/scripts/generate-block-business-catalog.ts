/**
 * 业务 Fetcher Catalog 生成脚本
 * 扫描 collection 目录下各区块的 definition.ts 与 fetcher.ts，生成服务端业务映射表
 */

import fs from "fs";
import path from "path";
import RLog from "rlog-js";
import { pathToFileURL } from "url";

interface BlockBusinessEntry {
  blockType: string;
  dirName: string;
  fetcherExportName: string;
}

const rlog = new RLog();

const COLLECTION_DIR = path.join(process.cwd(), "src", "blocks", "collection");
const OUTPUT_FILE = path.join(
  process.cwd(),
  "src",
  "blocks",
  "core",
  "generated",
  "business-fetcher-catalog.ts",
);

function ensureCollectionDirExists(): void {
  if (!fs.existsSync(COLLECTION_DIR)) {
    throw new Error(`Block collection directory not found: ${COLLECTION_DIR}`);
  }
}

function extractBlockType(
  definitionContent: string,
  definitionPath: string,
): string {
  const match = definitionContent.match(/type:\s*["']([^"']+)["']/);
  if (!match?.[1]) {
    throw new Error(`Unable to parse block type: ${definitionPath}`);
  }
  return match[1];
}

function extractFetcherExportName(
  fetcherContent: string,
  fetcherPath: string,
): string {
  const exportNamePattern =
    /export\s+(?:async\s+function|function|const)\s+([A-Za-z0-9_]*Fetcher)\b/g;
  const exportNames = Array.from(
    fetcherContent.matchAll(exportNamePattern),
  ).map((m) => m[1]);
  const uniqueExportNames = Array.from(new Set(exportNames));

  if (uniqueExportNames.length === 0) {
    throw new Error(
      `No *Fetcher export found in fetcher file, please check: ${fetcherPath}`,
    );
  }

  if (uniqueExportNames.length > 1) {
    throw new Error(
      `Multiple *Fetcher exports found in fetcher file, please keep only one primary export: ${fetcherPath} -> ${uniqueExportNames.join(
        ", ",
      )}`,
    );
  }

  const [fetcherExportName] = uniqueExportNames;
  if (!fetcherExportName) {
    throw new Error(`Unable to parse fetcher export name: ${fetcherPath}`);
  }

  return fetcherExportName;
}

function collectBlockBusinessEntries(): BlockBusinessEntry[] {
  const blockDirs = fs
    .readdirSync(COLLECTION_DIR, { withFileTypes: true })
    .filter((entry) => entry.isDirectory())
    .map((entry) => entry.name)
    .sort((a, b) => a.localeCompare(b));

  const entries: BlockBusinessEntry[] = [];

  for (const dirName of blockDirs) {
    const definitionPath = path.join(COLLECTION_DIR, dirName, "definition.ts");
    const fetcherPath = path.join(COLLECTION_DIR, dirName, "fetcher.ts");

    if (!fs.existsSync(definitionPath) || !fs.existsSync(fetcherPath)) {
      continue;
    }

    const definitionContent = fs.readFileSync(definitionPath, "utf-8");
    const fetcherContent = fs.readFileSync(fetcherPath, "utf-8");

    entries.push({
      blockType: extractBlockType(definitionContent, definitionPath),
      dirName,
      fetcherExportName: extractFetcherExportName(fetcherContent, fetcherPath),
    });
  }

  return entries.sort((a, b) => a.blockType.localeCompare(b.blockType));
}

function renderCatalogSource(entries: BlockBusinessEntry[]): string {
  const mappingRows = entries
    .map(
      (entry) =>
        `  "${entry.blockType}": () =>\n    import("@/blocks/collection/${entry.dirName}/fetcher").then(\n      (fetcherModule) => fetcherModule.${entry.fetcherExportName},\n    ),`,
    )
    .join("\n");

  return `/* eslint-disable */
// Auto-generated by scripts/generate-block-business-catalog.ts
// Do not edit this file manually.

import "server-only";

import type { RuntimeBlockInput } from "@/blocks/core/definition";

export type BlockBusinessFetcher = (
  block: RuntimeBlockInput,
) => Promise<unknown>;

const businessFetcherLoaders: Record<
  string,
  () => Promise<BlockBusinessFetcher>
> = {
${mappingRows}
};

export async function loadBlockBusinessFetcher(
  type: string,
): Promise<BlockBusinessFetcher | null> {
  const loader = businessFetcherLoaders[type];
  if (!loader) {
    return null;
  }

  return loader();
}
`;
}

function writeOutputFile(content: string): "updated" | "unchanged" {
  fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
  const previous = fs.existsSync(OUTPUT_FILE)
    ? fs.readFileSync(OUTPUT_FILE, "utf-8")
    : "";

  if (previous === content) {
    return "unchanged";
  }

  fs.writeFileSync(OUTPUT_FILE, content, "utf-8");
  return "updated";
}

export function generateBlockBusinessCatalog(): void {
  ensureCollectionDirExists();
  const entries = collectBlockBusinessEntries();
  const output = renderCatalogSource(entries);
  const status = writeOutputFile(output);

  if (status === "updated") {
    rlog.success("  Business fetcher catalog updated");
  } else {
    rlog.log("  Business fetcher catalog is up to date");
  }
  rlog.log(`  Found ${entries.length} business fetcher(s)`);
}

async function main() {
  rlog.log("Starting block business catalog generation...");
  try {
    generateBlockBusinessCatalog();
    rlog.success("Block business catalog generation completed");
    process.exit(0);
  } catch (error) {
    rlog.error(
      `Block business catalog generation failed: ${error instanceof Error ? error.message : String(error)}`,
    );
    process.exit(1);
  }
}

if (
  process.argv[1] &&
  import.meta.url === pathToFileURL(process.argv[1]).href
) {
  await main();
}
