/**
 * Definition Catalog 生成脚本
 * 扫描 collection 目录下各区块的 definition.ts，生成客户端可用的 definition 列表
 */

import fs from "fs";
import path from "path";
import RLog from "rlog-js";
import { pathToFileURL } from "url";

interface BlockDefinitionEntry {
  blockType: string;
  dirName: string;
  definitionExportName: string;
}

const rlog = new RLog();

const COLLECTION_DIR = path.join(process.cwd(), "src", "blocks", "collection");
const OUTPUT_FILE = path.join(
  process.cwd(),
  "src",
  "blocks",
  "core",
  "generated",
  "block-definitions.ts",
);

function ensureCollectionDirExists(): void {
  if (!fs.existsSync(COLLECTION_DIR)) {
    throw new Error(`Block collection directory not found: ${COLLECTION_DIR}`);
  }
}

function extractBlockType(
  definitionContent: string,
  definitionPath: string,
): string {
  const match = definitionContent.match(/type:\s*["']([^"']+)["']/);
  if (!match?.[1]) {
    throw new Error(`Unable to parse block type: ${definitionPath}`);
  }
  return match[1];
}

function extractDefinitionExportName(
  definitionContent: string,
  definitionPath: string,
): string {
  const pattern =
    /export\s+const\s+([A-Za-z0-9_]+)\s*=\s*createBlockDefinition\s*\(/g;
  const exportNames = Array.from(definitionContent.matchAll(pattern)).map(
    (m) => m[1],
  );
  const uniqueExportNames = Array.from(new Set(exportNames));

  if (uniqueExportNames.length === 0) {
    throw new Error(
      `No createBlockDefinition export found in definition file: ${definitionPath}`,
    );
  }

  if (uniqueExportNames.length > 1) {
    throw new Error(
      `Multiple createBlockDefinition exports found in definition file, please keep only one primary export: ${definitionPath} -> ${uniqueExportNames.join(
        ", ",
      )}`,
    );
  }

  const [definitionExportName] = uniqueExportNames;
  if (!definitionExportName) {
    throw new Error(
      `Unable to parse definition export name: ${definitionPath}`,
    );
  }

  return definitionExportName;
}

function collectBlockDefinitionEntries(): BlockDefinitionEntry[] {
  const blockDirs = fs
    .readdirSync(COLLECTION_DIR, { withFileTypes: true })
    .filter((entry) => entry.isDirectory())
    .map((entry) => entry.name)
    .sort((a, b) => a.localeCompare(b));

  const entries: BlockDefinitionEntry[] = [];

  for (const dirName of blockDirs) {
    const definitionPath = path.join(COLLECTION_DIR, dirName, "definition.ts");
    if (!fs.existsSync(definitionPath)) {
      continue;
    }

    const definitionContent = fs.readFileSync(definitionPath, "utf-8");
    entries.push({
      blockType: extractBlockType(definitionContent, definitionPath),
      dirName,
      definitionExportName: extractDefinitionExportName(
        definitionContent,
        definitionPath,
      ),
    });
  }

  return entries.sort((a, b) => a.blockType.localeCompare(b.blockType));
}

function renderCatalogSource(entries: BlockDefinitionEntry[]): string {
  const importLines = entries
    .map(
      (entry) =>
        `import { ${entry.definitionExportName} } from "@/blocks/collection/${entry.dirName}/definition";`,
    )
    .join("\n");

  const listRows = entries
    .map((entry) => `  ${entry.definitionExportName},`)
    .join("\n");

  return `/* eslint-disable */
// Auto-generated by scripts/generate-block-definition-catalog.ts
// Do not edit this file manually.

${importLines}
import type { BlockDefinition } from "@/blocks/core/definition";

export const BLOCK_DEFINITIONS = [
${listRows}
] as const satisfies readonly BlockDefinition[];
`;
}

function writeOutputFile(content: string): "updated" | "unchanged" {
  fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
  const previous = fs.existsSync(OUTPUT_FILE)
    ? fs.readFileSync(OUTPUT_FILE, "utf-8")
    : "";

  if (previous === content) {
    return "unchanged";
  }

  fs.writeFileSync(OUTPUT_FILE, content, "utf-8");
  return "updated";
}

export function generateBlockDefinitionCatalog(): void {
  ensureCollectionDirExists();
  const entries = collectBlockDefinitionEntries();
  const output = renderCatalogSource(entries);
  const status = writeOutputFile(output);

  if (status === "updated") {
    rlog.success("  Definition catalog updated");
  } else {
    rlog.log("  Definition catalog is up to date");
  }
  rlog.log(`  Found ${entries.length} definition(s)`);
}

async function main() {
  rlog.log("Starting block definition catalog generation...");
  try {
    generateBlockDefinitionCatalog();
    rlog.success("Block definition catalog generation completed");
    process.exit(0);
  } catch (error) {
    rlog.error(
      `Block definition catalog generation failed: ${error instanceof Error ? error.message : String(error)}`,
    );
    process.exit(1);
  }
}

if (
  process.argv[1] &&
  import.meta.url === pathToFileURL(process.argv[1]).href
) {
  await main();
}
